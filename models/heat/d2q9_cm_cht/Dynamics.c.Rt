<?R
	source("conf.R") 
	source("lib/boundary.R")
	c_header();

# Creating variables for symbolic computations
	f = PV(DensityAll$name[DensityAll$group=="f"])
	h = PV(DensityAll$name[DensityAll$group=="h"])
	rho =  PV("rho")
	u = PV(c("ux","uy"))
	rhoT = PV("rhoT")

# Extracting velocity set
	U = d2q9
	h_pop_size = PV("9")

# Calculating equlibrium density set
	source("lib/feq.R")
	J = PV("J",c("x","y","z"))
	EQ = MRT_eq(U, rho, J, ortogonal=FALSE);

	if (Options$OutFlow) 
	{
		f_neighbours = Density$nicename[Density$group =="f"]
		h_neighbours = Density$nicename[Density$group =="h"]
		f_old = PV(Density$name[Density$group == "fold"])
		h_old = PV(Density$name[Density$group == "hold"])
		f_n = PV(paste(f_neighbours,"(",-Density$dx[Density$group=="f"]-1,",",-Density$dy[Density$group=="f"],")",sep=""))
		h_n = PV(paste(h_neighbours,"(",-Density$dx[Density$group=="h"]-1,",",-Density$dy[Density$group=="h"],")",sep=""))
		U_loc = PV("U_local")
		U_inv = PV("invU")
	}
?>

CudaDeviceFunction real_t getm00_F(){
	real_t m00_F = <?R C(sum(f)) ?>;
	return m00_F/material_density; // TODO: or return m00_F; 
}

CudaDeviceFunction real_t getcp(){
	return cp;
}

CudaDeviceFunction real_t getmaterial_density(){
	return material_density;
}

CudaDeviceFunction real_t getconductivity(){
	return conductivity;
}

CudaDeviceFunction real_t getRho(){
	real_t m00_F = <?R C(sum(f)) ?>;
	return m00_F; // TODO: return m00_F* material_density; 
}

CudaDeviceFunction real_t getT(){
	real_t rho = getRho();
	real_t m00_H = <?R C(sum(h)) ?>;
	return m00_H/(rho*cp);
}


CudaDeviceFunction real_t getH(){
	return <?R C(sum(h)) ?>;
}

CudaDeviceFunction vector_t getRawU(){
	real_t rho = getRho();
	vector_t u;
  <?R C(PV(c("u.x","u.y", "u.z")), f %*% U) ?>
	u.x /= rho;
	u.y /= rho;
	u.z = 0;
	return u;
}

CudaDeviceFunction vector_t getU()
{
	real_t localTemperature = getT();
	vector_t u = getRawU();
	real_t rho = getRho();
	vector_t Force = getForce(localTemperature, rho);
	u.x += Force.x/(2*rho);
	u.y += Force.y/(2*rho);
	u.z = 0;
	return u;
}

CudaDeviceFunction vector_t get_fDarcyStoper(real_t rho, vector_t u)
{
	vector_t fDarcy;
	fDarcy.x = -2*rho*(u.x);
	fDarcy.y = -2*rho*(u.y);
	fDarcy.z = 0;
	return fDarcy;
}

CudaDeviceFunction float2 Color() {
	float2 ret;
	//vector_t u = getRawU();

	ret.x = getT();
	ret.y = ret.x;

	// ret.y = sqrt(u.x*u.x + u.y*u.y + u.z*u.z);
	return ret;
}


CudaDeviceFunction void EVelocity()
{}

CudaDeviceFunction void WPressure()
{}

CudaDeviceFunction void WVelocity()
{
	real_t rho, Rx;
	vector_t u;
	u.x=VelocityX; u.y=VelocityY; u.z=0;
	rho = ( f[0] + f[2] + f[4] + 2.*(f[3] + f[7] + f[6]) ) / (1. - u.x);
	Rx = rho * u.x;
	f[1] = f[3] + (2./3.) * Rx;
	f[5] = f[7] + (1./6.) * Rx + (1./2.)*(f[4] - f[2]);
	f[8] = f[6] + (1./6.) * Rx + (1./2.)*(f[2] - f[4]);

		// equilibrium scheme for Heat-BC - don't care and impose rho*Teq
	// see chapter 5.3.4.2, eq 5.34, p191 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

	real_t T = InitTemperature;
	real_t H = rho*cp*T;

	<?R C(PV(c("const int h_size")), h_pop_size) ?>
	real_t h_eq[h_size];
	SetEquilibriumHeat(h_eq, H, rho, u); 

	for (int i = 0; i < h_size; i++) {
		h[i] = h_eq[i];
	}
}

CudaDeviceFunction void EPressure()
{
	
		<?R 
	 			#ZouHe(EQ, 1, -1, "pressure")
				#ZouHeRewrite(EQ,   f, c(1,0), type="pressure")
		?>
			
		// 	ZouHe(EQ, 1, -1, "pressure") gives 
		// real_t Jx, Jy, Jz, rho;
		// rho = (1 + Pressure*3.);  // TODO: why pressure +1, shall add material density?!
		// Jx  =  f[4] - rho + f[2] + f[0] + ( f[8] + f[5] + f[1] )*2. ;
		// Jy  =  ( f[4] - f[2] )*3. ;
		// f[3] = f[1] - Jx*2./3.;
		// f[6] = f[8] + ( Jy - Jx )/6.;
		// f[7] = f[5] + ( -Jy - Jx )/6.;

		//ZouHeRewrite(EQ,   f, c(1,0), type="pressure") gives
		/********* pressure-type Zou He boundary condition  ****************/
	real_t rho = (material_density + Pressure*3.);  // TODO: why pressure +1, shall add material density?!
	real_t Rx  =  -rho + f[4] + f[2] + f[0] + ( f[8] + f[5] + f[1] )*2. ;
	real_t Ry  =  ( f[4] - f[2] )*3. ;
	f[3] = f[1] - Rx*2./3.;
	f[6] = f[8] + ( Ry - Rx )/6.;
	f[7] = f[5] + ( -Ry - Rx )/6.;
					
	// equilibrium scheme for Heat-BC - don't care and impose rho*Teq
	// see chapter 5.3.4.2, eq 5.34, p191 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

		real_t T = InitTemperature;
		vector_t u;
		u.x= Rx/rho; u.y=Ry/rho; u.z=0;  

		real_t H = rho*cp*T;

		<?R C(PV(c("const int h_size")), h_pop_size) ?>
		real_t h_eq[h_size];
		SetEquilibriumHeat(h_eq, H, rho, u); 

		for (int i = 0; i < h_size; i++) {
			h[i] = h_eq[i];
		}
}

//	BOUNDARY CONDITIONS:
#ifdef OPTIONS_OutFlow
#define myMax(a,b) \
   ({ __typeof__ (a) _a = (a); \
       __typeof__ (b) _b = (b); \
     _a > _b ? _a : _b; })

CudaDeviceFunction void EConvect()
{
	real_t U_local = myMax(0, U(-1,0,0)); // TODO: anty-cofka?
	real_t invU = 1.0/(1+ U_local);

	<?R
		if (Options$OutFlow) {
			C(f, (f_old + U_loc*f_n)*U_inv)
			C(f_old, f)

			C(h, (h_old + U_loc*h_n)*U_inv)
			C(h_old, h)
		}
	?>
}

CudaDeviceFunction void ENeumann()
{
	// TODO: is this really Neumann... or just simple extrapolation?
	<?R
		if (Options$OutFlow){
			C(f, PV(paste0(f_neighbours,"(",-Density$dx[Density$group=="f"]-1,",",-Density$dy[Density$group=="f"],")")))
			C(h, PV(paste0(h_neighbours,"(",-Density$dx[Density$group=="h"]-1,",",-Density$dy[Density$group=="h"],")")))
	}
	?>
}
#endif
CudaDeviceFunction void HeaterSource()
{
	real_t h1 = <?R C(sum(h)) ?>;

	real_t T = InitTemperature;
	real_t rho = getRho();
	vector_t u = getU();
	// TCLB is smart enough to distiguish values prescribed it batch.xml like
	// InitTemperature-dirichlet_region="123"
	// InitTemperature-neumann_heater_region="456"
	real_t H = rho*cp*T;  
	real_t h_source[9];
	SetEquilibriumHeat(h_source, H, rho, u); 
	for (int i = 0; i < 9; i++) {
		h[i] += h_source[i];}

	real_t h2 = <?R C(sum(h)) ?>;
	AddToHeatSource(h2-h1);
}

CudaDeviceFunction void HeatDirichletEquilibriumScheme()
{
	// equilibrium scheme for BC - don't care and impose rho*Teq
	// see chapter 5.3.4.2, eq 5.34, p191 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

	real_t h1 = <?R 	C(sum(h)) ?>;

	real_t T = InitTemperature;
	real_t rho = getRho();
	vector_t u = getU();
	
	real_t H = rho*cp*T;
	real_t h_eq[9];
	SetEquilibriumHeat(h_eq, H, rho, u); 

	for (int i = 0; i < 9; i++) {
		h[i] = h_eq[i];
	}

	real_t h2 = <?R C(sum(h)) ?>;
	AddToHeatSource(h2-h1);
}

CudaDeviceFunction void HeatDirichletAntiBounceBackScheme()
{


	// Anti-Bounce-Back Scheme
	// see chapter 8.5.2.1, eq 8.53, p318 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

	real_t h1 = <?R 	C(sum(h)) ?>;

	real_t T = InitTemperature;
	real_t rho = getRho();
	vector_t u = getU();

	real_t H = rho*cp*T;
	real_t h_eq[9];
	SetEquilibriumHeat(h_eq, H, rho, u);

	for (int i = 0; i < 9; i++) {
		h[i] = -h[i] + 2*h_eq[i]; // #TODO: make bounce back first!!! 
	}
	real_t h2 = <?R C(sum(h)) ?>;
	AddToHeatSource(h2-h1);
}


CudaDeviceFunction void Run() {
	vector_t p1;
	if((NodeType & NODE_BODY) == NODE_MeasurmentArea) {
		<?R C(PV(c("p1.x","p1.y", "p1.z")), f %*% U) ?>
	}

    switch (NodeType & NODE_BOUNDARY) {
		case NODE_EVelocity:
			EVelocity();
			break;
		case NODE_WPressure:
			WPressure();
			break;
		case NODE_WVelocity:
			WVelocity();
			break;
		case NODE_EPressure:
			EPressure();
			break;
		case NODE_Wall:
			BounceBack(); // Force Measurment here
			break;
		#ifdef OPTIONS_OutFlow
			case NODE_EConvect:
				EConvect();
				break;
			case NODE_ENeumann:
				ENeumann();
				break;
		#endif
	}
	
    switch (NodeType & NODE_COLLISION) {
		case NODE_CM:
			CollisionCM();
			break;
	}

	if ((NodeType & NODE_ADDITIONALS_HEAT) == NODE_HeaterDirichletTemperature) {
		HeatDirichletEquilibriumScheme();
		// alternatively:
		// HeatDirichletAntiBounceBackScheme();
	}

	if ((NodeType & NODE_ADDITIONALS_HEAT) == NODE_HeaterSource) {
		HeaterSource();
	}
	
	if((NodeType & NODE_BODY) == NODE_MeasurmentArea) {
		vector_t h2,p2;
		<?R C(PV(c("h2.x","h2.y", "h2.z")), h %*% U) ?>
		// Summing the heat flux (both convective and diffusive) before/after collision
		// convective flux - eq part of h distributions
		// diffusive flux - neq part of h distributions

    AddToHeatFluxX(-h2.x);
    AddToHeatFluxY(-h2.y);
		// AddToHeatFluxZ(-(h2.z-h1.z));
		// AddToHeatSource(-(h2.x-h1.x) -(h2.y-h1.y));

		<?R # C(PV(c("p2.x","p2.y", "p2.z")), f %*% U) ?>
		//Summing the difference in momentum before/after collision

    AddToFDrag(-(p2.x-p1.x));
    AddToFLift(-(p2.y-p1.y));
	}
}



CudaDeviceFunction void BounceBack()
{
	<?R 
		# TODO: BounceBack gets crazy and bounces h_old and f_old in _Outflow mode :/
		#	FullBounceBack() 
	?>

	real_t tmp;
	tmp = f[6];
	f[6] = f[8];
	f[8] = tmp;
	tmp = f[2];
	f[2] = f[4];
	f[4] = tmp;
	tmp = f[1];
	f[1] = f[3];
	f[3] = tmp;
	tmp = f[5];
	f[5] = f[7];
	f[7] = tmp;
	tmp = h[6];
	h[6] = h[8];
	h[8] = tmp;
	tmp = h[2];
	h[2] = h[4];
	h[4] = tmp;
	tmp = h[1];
	h[1] = h[3];
	h[3] = tmp;
	tmp = h[5];
	h[5] = h[7];
	h[7] = tmp;
}

CudaDeviceFunction void SetEquilibriumFluid(real_t f_in[9], real_t rho, vector_t u) 
{
	// #TODO: with Force?
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;

	real_t temp[9];

	//equilibrium in central moments space
	f_in[0] = rho;
	f_in[1] = 0;
	f_in[2] = 0;
	f_in[3] = 1/3.*rho;
	f_in[4] = 1/3.*rho;
	f_in[5] = 0;
	f_in[6] = 0;
	f_in[7] = 0;
	f_in[8] = 1/9.*rho;

	//back to raw moments
	temp[0] = f_in[0];
	temp[1] = u.x*f_in[0] + f_in[1];
	temp[2] = u.y*f_in[0] + f_in[2];
	temp[3] = ux2*f_in[0] + 2.*u.x*f_in[1] + f_in[3];
	temp[4] = uy2*f_in[0] + 2.*u.y*f_in[2] + f_in[4];
	temp[5] = uxuy*f_in[0] + u.x*f_in[2] + u.y*f_in[1] + f_in[5];
	temp[6] = ux2*u.y*f_in[0] + ux2*f_in[2] + 2.*uxuy*f_in[1] + 2.*u.x*f_in[5] + u.y*f_in[3] + f_in[6];
	temp[7] = u.x*uy2*f_in[0] + 2.*uxuy*f_in[2] + u.x*f_in[4] + uy2*f_in[1] + 2.*u.y*f_in[5] + f_in[7];
	temp[8] = ux2*uy2*f_in[0] + 2.*ux2*u.y*f_in[2] + ux2*f_in[4] + 2.*u.x*uy2*f_in[1] + 4.*uxuy*f_in[5] + 2.*u.x*f_in[7] + uy2*f_in[3] + 2.*u.y*f_in[6] + f_in[8];

	//back to density-probability functions
	f_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	f_in[1] = 1/2.*temp[1] + 1/2.*temp[3] - 1/2.*temp[7] - 1/2.*temp[8];
	f_in[2] = 1/2.*temp[2] + 1/2.*temp[4] - 1/2.*temp[6] - 1/2.*temp[8];
	f_in[3] = -1/2.*temp[1] + 1/2.*temp[3] + 1/2.*temp[7] - 1/2.*temp[8];
	f_in[4] = -1/2.*temp[2] + 1/2.*temp[4] + 1/2.*temp[6] - 1/2.*temp[8];
	f_in[5] = 1/4.*temp[5] + 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
	f_in[6] = -1/4.*temp[5] + 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	f_in[7] = 1/4.*temp[5] - 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	f_in[8] = -1/4.*temp[5] - 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];

}

CudaDeviceFunction void SetEquilibriumHeat(real_t h_in[9], real_t H, real_t rho, vector_t u) 
{
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;

	real_t temp[9];
	real_t Sigma2 = (h_stability_enhancement*1./3.)/(cp*rho);

	//equilibrium in central moments space
	h_in[0] = H;
	h_in[1] = 0;
	h_in[2] = 0;
	h_in[3] = H*Sigma2;
	h_in[4] = H*Sigma2;
	h_in[5] = 0;
	h_in[6] = 0;
	h_in[7] = 0;
	h_in[8] = H*Sigma2*Sigma2;

	//back to raw moments
	temp[0] = h_in[0];
	temp[1] = u.x*h_in[0] + h_in[1];
	temp[2] = u.y*h_in[0] + h_in[2];
	temp[3] = ux2*h_in[0] + 2.*u.x*h_in[1] + h_in[3];
	temp[4] = uy2*h_in[0] + 2.*u.y*h_in[2] + h_in[4];
	temp[5] = uxuy*h_in[0] + u.x*h_in[2] + u.y*h_in[1] + h_in[5];
	temp[6] = ux2*u.y*h_in[0] + ux2*h_in[2] + 2.*uxuy*h_in[1] + 2.*u.x*h_in[5] + u.y*h_in[3] + h_in[6];
	temp[7] = u.x*uy2*h_in[0] + 2.*uxuy*h_in[2] + u.x*h_in[4] + uy2*h_in[1] + 2.*u.y*h_in[5] + h_in[7];
	temp[8] = ux2*uy2*h_in[0] + 2.*ux2*u.y*h_in[2] + ux2*h_in[4] + 2.*u.x*uy2*h_in[1] + 4.*uxuy*h_in[5] + 2.*u.x*h_in[7] + uy2*h_in[3] + 2.*u.y*h_in[6] + h_in[8];

	//back to density-probability functions
	h_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	h_in[1] = 1/2.*temp[1] + 1/2.*temp[3] - 1/2.*temp[7] - 1/2.*temp[8];
	h_in[2] = 1/2.*temp[2] + 1/2.*temp[4] - 1/2.*temp[6] - 1/2.*temp[8];
	h_in[3] = -1/2.*temp[1] + 1/2.*temp[3] + 1/2.*temp[7] - 1/2.*temp[8];
	h_in[4] = -1/2.*temp[2] + 1/2.*temp[4] + 1/2.*temp[6] - 1/2.*temp[8];
	h_in[5] = 1/4.*temp[5] + 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
	h_in[6] = -1/4.*temp[5] + 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	h_in[7] = 1/4.*temp[5] - 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	h_in[8] = -1/4.*temp[5] - 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
}


CudaDeviceFunction void Init() {
	real_t rho = 1.0*material_density;
	real_t H = rho*cp*InitTemperature;
	vector_t u; u.x = VelocityX; u.y = VelocityY; u.z = 0;

	SetEquilibriumFluid(f,rho,u);
	SetEquilibriumHeat(h,H,rho,u);

	#ifdef OPTIONS_OutFlow
	if ((NodeType & NODE_BOUNDARY) == NODE_EConvect){
			<?R if (Options$OutFlow)
				{
					C(f_old, f)
					C(h_old, h)     
				}       
			?>
	}
	#endif
}

CudaDeviceFunction void relax_and_collide_hydro_with_F(real_t x_in[9], real_t rho, real_t omega_nu, vector_t u, vector_t F) 
{
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;
	real_t m00 = x_in[0] + x_in[1] + x_in[2] + x_in[3] + x_in[4] + x_in[5] + x_in[6] + x_in[7] + x_in[8];
	real_t temp[9];
	for (int i = 0; i < 9; i++) {
		temp[i] = x_in[i];}
	//raw moments from density-probability functions
	x_in[0] = temp[0] + temp[1] + temp[2] + temp[3] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	x_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
	x_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
	x_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
	x_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	x_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
	x_in[6] = temp[5] + temp[6] - temp[7] - temp[8];
	x_in[7] = temp[5] - temp[6] - temp[7] + temp[8];
	x_in[8] = temp[5] + temp[6] + temp[7] + temp[8];
	//central moments from raw moments
	temp[0] = x_in[0];
	temp[1] = -u.x*x_in[0] + x_in[1];
	temp[2] = -u.y*x_in[0] + x_in[2];
	temp[3] = ux2*x_in[0] - 2.*u.x*x_in[1] + x_in[3];
	temp[4] = uy2*x_in[0] - 2.*u.y*x_in[2] + x_in[4];
	temp[5] = uxuy*x_in[0] - u.x*x_in[2] - u.y*x_in[1] + x_in[5];
	temp[6] = -ux2*u.y*x_in[0] + ux2*x_in[2] + 2.*uxuy*x_in[1] - 2.*u.x*x_in[5] - u.y*x_in[3] + x_in[6];
	temp[7] = -u.x*uy2*x_in[0] + 2.*uxuy*x_in[2] - u.x*x_in[4] + uy2*x_in[1] - 2.*u.y*x_in[5] + x_in[7];
	temp[8] = ux2*uy2*x_in[0] - 2.*ux2*u.y*x_in[2] + ux2*x_in[4] - 2.*u.x*uy2*x_in[1] + 4.*uxuy*x_in[5] - 2.*u.x*x_in[7] + uy2*x_in[3] - 2.*u.y*x_in[6] + x_in[8];
	//collision in central moments space
	//collide
	x_in[0] = m00;
	x_in[1] = 1/2.*F.x/rho;
	x_in[2] = 1/2.*F.y/rho;
	x_in[3] = 1/3.*m00*omega_bulk - 1/2.*omega_bulk*temp[3] - 1/2.*omega_bulk*temp[4] - 1/2.*omega_nu*temp[3] + 1/2.*omega_nu*temp[4] + temp[3];
	x_in[4] = 1/3.*m00*omega_bulk - 1/2.*omega_bulk*temp[3] - 1/2.*omega_bulk*temp[4] + 1/2.*omega_nu*temp[3] - 1/2.*omega_nu*temp[4] + temp[4];
	x_in[5] = -temp[5]*(omega_nu - 1.);
	x_in[6] = 1/6.*F.y/rho;
	x_in[7] = 1/6.*F.x/rho;
	x_in[8] = 1/9.*m00;
	//back to raw moments
	temp[0] = x_in[0];
	temp[1] = u.x*x_in[0] + x_in[1];
	temp[2] = u.y*x_in[0] + x_in[2];
	temp[3] = ux2*x_in[0] + 2.*u.x*x_in[1] + x_in[3];
	temp[4] = uy2*x_in[0] + 2.*u.y*x_in[2] + x_in[4];
	temp[5] = uxuy*x_in[0] + u.x*x_in[2] + u.y*x_in[1] + x_in[5];
	temp[6] = ux2*u.y*x_in[0] + ux2*x_in[2] + 2.*uxuy*x_in[1] + 2.*u.x*x_in[5] + u.y*x_in[3] + x_in[6];
	temp[7] = u.x*uy2*x_in[0] + 2.*uxuy*x_in[2] + u.x*x_in[4] + uy2*x_in[1] + 2.*u.y*x_in[5] + x_in[7];
	temp[8] = ux2*uy2*x_in[0] + 2.*ux2*u.y*x_in[2] + ux2*x_in[4] + 2.*u.x*uy2*x_in[1] + 4.*uxuy*x_in[5] + 2.*u.x*x_in[7] + uy2*x_in[3] + 2.*u.y*x_in[6] + x_in[8];
	//back to density-probability functions
	x_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	x_in[1] = 1/2.*temp[1] + 1/2.*temp[3] - 1/2.*temp[7] - 1/2.*temp[8];
	x_in[2] = 1/2.*temp[2] + 1/2.*temp[4] - 1/2.*temp[6] - 1/2.*temp[8];
	x_in[3] = -1/2.*temp[1] + 1/2.*temp[3] + 1/2.*temp[7] - 1/2.*temp[8];
	x_in[4] = -1/2.*temp[2] + 1/2.*temp[4] + 1/2.*temp[6] - 1/2.*temp[8];
	x_in[5] = 1/4.*temp[5] + 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
	x_in[6] = -1/4.*temp[5] + 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	x_in[7] = 1/4.*temp[5] - 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	x_in[8] = -1/4.*temp[5] - 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
}

CudaDeviceFunction void relax_and_collide_ADE(real_t h_in[9], real_t rho, real_t omega_ade, vector_t u) 
{
	//=== THIS IS AUTOMATICALLY GENERATED CODE: relax and collide ===
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;


	real_t H = h_in[0] + h_in[1] + h_in[2] + h_in[3] + h_in[4] + h_in[5] + h_in[6] + h_in[7] + h_in[8];

	real_t Sigma2 = (h_stability_enhancement*1./3.)/(cp*rho);

	real_t temp[9];
	for (int i = 0; i < 9; i++) {
		temp[i] = h_in[i];}
	//raw moments from density-probability functions
	h_in[0] = temp[0] + temp[1] + temp[2] + temp[3] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	h_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
	h_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
	h_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
	h_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	h_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
	h_in[6] = temp[5] + temp[6] - temp[7] - temp[8];
	h_in[7] = temp[5] - temp[6] - temp[7] + temp[8];
	h_in[8] = temp[5] + temp[6] + temp[7] + temp[8];
	//central moments from raw moments
	temp[0] = h_in[0];
	temp[1] = -u.x*h_in[0] + h_in[1];
	temp[2] = -u.y*h_in[0] + h_in[2];
	temp[3] = ux2*h_in[0] - 2.*u.x*h_in[1] + h_in[3];
	temp[4] = uy2*h_in[0] - 2.*u.y*h_in[2] + h_in[4];
	temp[5] = uxuy*h_in[0] - u.x*h_in[2] - u.y*h_in[1] + h_in[5];
	temp[6] = -ux2*u.y*h_in[0] + ux2*h_in[2] + 2.*uxuy*h_in[1] - 2.*u.x*h_in[5] - u.y*h_in[3] + h_in[6];
	temp[7] = -u.x*uy2*h_in[0] + 2.*uxuy*h_in[2] - u.x*h_in[4] + uy2*h_in[1] - 2.*u.y*h_in[5] + h_in[7];
	temp[8] = ux2*uy2*h_in[0] - 2.*ux2*u.y*h_in[2] + ux2*h_in[4] - 2.*u.x*uy2*h_in[1] + 4.*uxuy*h_in[5] - 2.*u.x*h_in[7] + uy2*h_in[3] - 2.*u.y*h_in[6] + h_in[8];
	//collision in central moments space
	//collide
	h_in[0] = H;
	h_in[1] = -temp[1]*(omega_ade - 1.);
	h_in[2] = -temp[2]*(omega_ade - 1.);
	h_in[3] = Sigma2*H;
	h_in[4] = Sigma2*H;
	h_in[5] = 0;
	h_in[6] = 0;
	h_in[7] = 0;
	h_in[8] = Sigma2*Sigma2*H;
	//back to raw moments
	temp[0] = h_in[0];
	temp[1] = u.x*h_in[0] + h_in[1];
	temp[2] = u.y*h_in[0] + h_in[2];
	temp[3] = ux2*h_in[0] + 2.*u.x*h_in[1] + h_in[3];
	temp[4] = uy2*h_in[0] + 2.*u.y*h_in[2] + h_in[4];
	temp[5] = uxuy*h_in[0] + u.x*h_in[2] + u.y*h_in[1] + h_in[5];
	temp[6] = ux2*u.y*h_in[0] + ux2*h_in[2] + 2.*uxuy*h_in[1] + 2.*u.x*h_in[5] + u.y*h_in[3] + h_in[6];
	temp[7] = u.x*uy2*h_in[0] + 2.*uxuy*h_in[2] + u.x*h_in[4] + uy2*h_in[1] + 2.*u.y*h_in[5] + h_in[7];
	temp[8] = ux2*uy2*h_in[0] + 2.*ux2*u.y*h_in[2] + ux2*h_in[4] + 2.*u.x*uy2*h_in[1] + 4.*uxuy*h_in[5] + 2.*u.x*h_in[7] + uy2*h_in[3] + 2.*u.y*h_in[6] + h_in[8];
	//back to density-probability functions
	h_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	h_in[1] = 1/2.*temp[1] + 1/2.*temp[3] - 1/2.*temp[7] - 1/2.*temp[8];
	h_in[2] = 1/2.*temp[2] + 1/2.*temp[4] - 1/2.*temp[6] - 1/2.*temp[8];
	h_in[3] = -1/2.*temp[1] + 1/2.*temp[3] + 1/2.*temp[7] - 1/2.*temp[8];
	h_in[4] = -1/2.*temp[2] + 1/2.*temp[4] + 1/2.*temp[6] - 1/2.*temp[8];
	h_in[5] = 1/4.*temp[5] + 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
	h_in[6] = -1/4.*temp[5] + 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	h_in[7] = 1/4.*temp[5] - 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	h_in[8] = -1/4.*temp[5] - 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
}


CudaDeviceFunction vector_t getForce(real_t localTemp, real_t rho)
{
	// Boussinesq approximation
	// rho(T) ~ rho_0*(1-thermal_exp_coeff*(Temp-Temp_0))
	// F_b = (rho(T) - rho_0)*Grav_Y = -Grav_Y*rho_0*thermal_exp_coeff*(Temp-Temp_0)
	// see chapter 8.4.1, eq 8.44, p313 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen
	real_t refTemperature = 0;
	real_t BoussinesqForce = -GravitationY*BoussinesqCoeff*(localTemp - refTemperature); // BoussinesqCoeff=rho_0*thermal_exp_coeff

	vector_t Force; 
	Force.x = GravitationX*rho; 
	Force.y = GravitationY*rho+BoussinesqForce; 
	Force.z = 0;

	return Force;
}

CudaDeviceFunction void CollisionCM()
{
	real_t localTemperature = getT();
	real_t rho = getRho();

	vector_t Force = getForce(localTemperature, rho);
	vector_t u = getRawU();
	u.x += Force.x/(2*rho);
	u.y += Force.y/(2*rho);


	// add Darcy force to stop flow within solid regions
	if ((NodeType & NODE_ADDITIONALS) == NODE_DarcySolid) 
	{
		vector_t fDarcyStoper = get_fDarcyStoper(rho,  u);
		Force.x += fDarcyStoper.x;
		Force.y += fDarcyStoper.y;
	} 
	relax_and_collide_hydro_with_F(f, rho, omega_nu, u, Force);	

	#ifdef OPTIONS_OutFlow
		U = u.x; // for convective outlet BC
	#endif	
	real_t omega_k = 1.0/(3*conductivity+0.5);
	relax_and_collide_ADE(h, rho, omega_k, u);  // TODO: a moze kolizja z nowym u po hydro kolizji ktora ma juz darcy stopper?
}
