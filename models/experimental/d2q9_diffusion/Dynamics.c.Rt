<?R  
	source("conf.R")
	c_header();
	source("lib/boundary.R")
	source("lib/feq.R")


	if (NumberOfDREs > 0){
		i = 1
		gname = paste("dre",i,sep="_")
		dre_gnames = c(gname)
		fs = list( PV(DensityAll$name[DensityAll$group==gname]) )	
		while (i < NumberOfDREs + 1 ) {
		# declaration of densities
			i = i + 1
			gname =  paste("dre",i,sep="_")
			dre_gnames = append(dre_gnames, gname)
			fs = append( fs, list(PV(DensityAll$name[DensityAll$group==gname]) ))
		}	
	}

	if (NumberOfODEs > 0){
		i = 1
		gname = paste("ode",i,sep="_")
		ode_gnames = c(gname)
		odes = list( PV(Fields$name[Fields$group==gname]) )	
		while (i < NumberOfODEs + 1) {
		# declaration of densities
			i = i + 1
			gname =  paste("ode",i,sep="_")
			ode_gnames = append(ode_gnames, gname)
			odes = append( odes, PV(Fields$name[Fields$group==gname]) )
		}	
	}

	f_tmp = c(PV(paste('f_tmp[',seq(0,8),']', sep='')))
	qs = c(PV(paste('q[',seq(0,NumberOfODEs + NumberOfDREs),']', sep='')))

?>
//this is object-wide variable
real_t f_tmp[9];
real_t q[<?%s NumberOfODEs + NumberOfDREs ?>];
real_t phi[<?%s NumberOfODEs + NumberOfDREs ?>];


CudaDeviceFunction float2 Color() {
  float2 ret;
  ret.x = 0;
  ret.y = <?R C(sum(fs[[1]])) ?>;
  return ret;
}

// ------------------------ PARAVIEW OUTPUT BLOCK ------------------------
// Use this functions is only for vtk output.

<?R
dre_loop( function(i) {
?>
CudaDeviceFunction real_t getDRE_<?%s i ?>() {
	return <?R C(sum(fs[[i]])) ?>;
}
<?R
})
?>

<?R
ode_loop( function(i) {
?>
CudaDeviceFunction real_t getODE_<?%s i ?>() {
	return <?R C(odes[[i]]) ?>;
}
<?R
})
?>



// ------------------------ END OF PARAVIEW OUTPUT BLOCK ------------------------

CudaDeviceFunction void Init() { 
	<?R


	dre_loop( function(i) {
		?>
		phi[<?%s i-1 ?>] = Init_DRE_<?%s i ?>;
		<?R
	})

	ode_loop( function(i) {
		?>
		phi[<?%s NumberOfDREs+i ?>] = Init_ODE_<?%s i ?>;
		<?R		
	})

	?>

	CalcQ();

	<?R


	dre_loop( function(i) {
		?>
		Init_eq(Init_DRE_<?%s i ?> - 0.5*q[<?%s i-1 ?>]);
		<?R
		C(fs[[i]], f_tmp)
	})

	ode_loop( function(i) {
		C(odes[[i]], PV(paste('Init_ODE_',i,sep='')) - 0.5*qs[NumberOfDREs+i] );
	})

	?>

}


	
CudaDeviceFunction void Run() {
	CalcPhi();
	CalcQ();
	<?R

	dre_loop( function(i) {
		C(f_tmp,fs[[i]])
		?>
		SRT(Diffusivity_DRE_<?%s i ?>, q[<?%s i-1 ?>]);
		<?R
		C(fs[[i]], f_tmp)
	})

	ode_loop( function(i) {
		C(odes[[i]], odes[[i]] + qs[NumberOfDREs+i] );
	})

	?>

 }

 CudaDeviceFunction void Init_eq(real_t Init_Phi_Tilde) 
 {

	<?R
		Init_Phi_Tilde = PV('Init_Phi_Tilde')
		U = as.matrix(Density[Density$group=='dre_1',c("dx","dy")])
		feq = MRT_feq(U, Init_Phi_Tilde, c(0,0))
		q = PV('q')		
		C(f_tmp, feq)

	?>

 }

CudaDeviceFunction void SRT(real_t diffusivity, const real_t q) 
{


	real_t omega_ade = 1.0/(3*diffusivity+0.5);
	real_t tilde_phi = <?%s  C(sum(f_tmp)) ?>;

	<?R
		omega = PV('omega_ade')
		tilde_phi = PV('tilde_phi')
		q = PV('q')

		U = as.matrix(Density[Density$group=='dre_1',c("dx","dy")])
		feq = MRT_feq(U, tilde_phi, c(0,0))
		qeq = MRT_feq(U, q, c(0,0))

		C(f_tmp, f_tmp - omega*(f_tmp-feq) + qeq)

	?>
}



<?R 
	if (Qname == 'Allen-Cahn') {
?>


	CudaDeviceFunction void CalcPhi() 
	{	
		real_t tilde_phi = <?%s  C(sum(fs[[1]])) ?>;

		const real_t dt = 1.;
		const real_t lambda = C_1;
		const real_t  x0 = cbrt(3.) ; 
		const real_t  x1 = 1/(dt*lambda) ; 
		const real_t  x2 = dt*lambda - 2 ; 
		const real_t  x3 = cbrt(-9*tilde_phi*x1 + sqrt(3.)*sqrt((27*pow(tilde_phi, 2) - x1*pow(x2, 3))/(pow(dt, 2)*pow(lambda, 2)))) ; 
		phi[0] = -1.0/3.0*x0*(x0*x1*x2 + pow(x3, 2))/x3 ;  
	}
	CudaDeviceFunction void CalcQ() 
	{	
		const real_t lambda = C_1;
		q[0] = lambda*phi[0]*(1 - pow(phi[0], 2)) ;
	}
<?R		
	}
?>



<?R 
	if (Qname == 'SIR_SimpleLaplace') {
?>


	CudaDeviceFunction void CalcPhi() 
	{	
		const real_t x0 = <?%s  C(sum(fs[[1]])) ?>;
		const real_t x1 = <?%s  C(sum(fs[[2]])) ?>;
		const real_t x2 = <?%s  C(sum(fs[[3]])) ?>;

		//x0 = S^\star
		//x1 = I^\star
		//x2 = R^\star
		const real_t x3 = C_1;
		const real_t x4 = 1;

		// Opers0 =  356
		const real_t  x5 = 4*x4 ; // 1
		const real_t  x6 = pow(x4, 2) ; // 1
		const real_t  x7 = x0*x3 ; // 1
		const real_t  x8 = x1*x3 ; // 1
		const real_t  x9 = 2*x6 ; // 1
		const real_t  x10 = pow(x3, 2)*x6 ; // 2
		const real_t  x11 = sqrt(x10*(pow(x0, 2) + 2*x0*x1 + pow(x1, 2)) - x5*x7 + x5*x8 + x5 + x6 - x7*x9 + x8*x9 + 4) ; // 20
		const real_t  x12 = x4 + 2 ; // 1
		const real_t  x13 = x11 + x12 ; // 1
		const real_t  x14 = x3*x4 ; // 1
		const real_t  x15 = x0*x14 ; // 1
		const real_t  x16 = x1*x14 ; // 1
		const real_t  x17 = x15 + x16 ; // 1
		const real_t  x18 = 1.0/x3 ; // 1
		const real_t  x19 = x18/x4 ; // 1
		const real_t  x20 = (1.0/2.0)*x19 ; // 1
		const real_t  x21 = 1.0/x12 ; // 1
		const real_t  x22 = x19*x21 ; // 1
		const real_t  x23 = -x11 + x17 ; // 1
		const real_t  x24 = -x4 - 2 ; // 2
		const real_t  x25 = 2*x2*(x14 + 2*x3) ; // 4
		const real_t  x26 = (1.0/2.0)*x18*x21 ; // 2
		const real_t  x27 = x11 + x17 + x24 ; // 2
		const real_t Sp = x20*(x13 + x17) ; // 2
		const real_t Ip = x22*(-x13 + x15 + x16) ; // 3
		const real_t Rp = x26*(x23 + x24 + x25) ; // 3
		const real_t Sm = x20*(x12 + x23) ; // 2
		const real_t Im = x22*x27 ; // 1
		const real_t Rm = x26*(x25 + x27) ; // 2
		// Opers =  91


		phi[0] = Sp >=0 ? Sp : Sm;
		phi[1] = Ip >=0 ? Ip : Im;
		phi[2] = Rp >=0 ? Rp : Rm;


	}
	CudaDeviceFunction void CalcQ() 
	{	
		const real_t R0 = C_1;

		const real_t  x0 = R0*phi[0] ; 
		q[0] = -phi[1]*x0 ; 
		q[1] =  phi[1]*(x0 - 1.) ;
		q[2] =  phi[1] ; 

	}
<?R		
	}
?>


