// Model for solving the spatial Allen Cahn equation.
// This model is to compare first (Euler) and second (Trapezoidal) integration scheme for the source term, Q=lambda*phi*(1-phi^2)
// phi' =  M*lap(phi) + lambda*phi*(1-phi^2)
// phi' =  M *(phi_xx + phi_yy) + lambda*phi*(1-phi^2)
// maintainer: Grzegorz Gruszczynski @ggruszczynski


<?R  
	source("conf.R")
	c_header();
	source("lib/boundary.R")

  	f = PV(DensityAll$name[DensityAll$group=="f"])

?>

CudaDeviceFunction float2 Color() {
  float2 ret;
  ret.x = 0;
  ret.y = <?R C(sum(f)) ?>;
  return ret;
}

// ------------------------ PARAVIEW OUTPUT BLOCK ------------------------
// Use this functions is only for vtk output.
// Nodes are created using streamed, post-collision DF.
// RunBoundaries are called in orded to assign the desired value at the boundary.
// It can make a difference in convergence study and nicer preview.

CudaDeviceFunction real_t getPhaseField() {
	RunBoundaries();
	return (<?R C(sum(f)) ?>);
}


CudaDeviceFunction real_t getQ() 
{	
	RunBoundaries();
	real_t tilde_phi = f000 + f010 + f020 + f100 + f110 + f120 + f200 + f210 + f220;

	const real_t dt = 1.;
	real_t phi;
	const real_t  x0 = cbrt(3.) ; 
	const real_t  x1 = 1/(dt*lambda) ; 
	const real_t  x2 = dt*lambda - 2 ; 
	const real_t  x3 = cbrt(-9*tilde_phi*x1 + sqrt(3.)*sqrt((27*pow(tilde_phi, 2) - x1*pow(x2, 3))/(pow(dt, 2)*pow(lambda, 2)))) ; 
	phi = -1.0/3.0*x0*(x0*x1*x2 + pow(x3, 2))/x3 ;  
	real_t Q;
	Q = lambda*phi*(1 - pow(phi, 2)) ;
	
	//return 0; // HACK:
	return Q; 
}

// future
// CudaDeviceFunction real_t getRandomCPU() {
// 	real_t x = real_t(rand()) / real_t(RAND_MAX);  // x is from 0 to 1
// 	x = 2.*x -1.;  // x is from -1 to 1
// 	return x;
// }

// https://gist.github.com/NicholasShatokhin/3769635
// CudaDeviceFunction real_t getRandom() {
//   /* CUDA's random number library uses curandState_t to keep track of the seed value
//      we will store a random state for every thread  */
// 	 curandState_t state;

// 	 /* we have to initialize the state */
// 	 curand_init(0, /* the seed controls the sequence of random values that are produced */
// 				 0, /* the sequence number is only important with multiple cores */
// 				 0, /* the offset is how much extra we advance in the sequence for each call, can be 0 */
// 				 &state);
   
// 	 /* curand works like rand - except that it takes a state as a parameter */
// 	 real_t result = curand(&state) % MAX;

// 	 return result;
// }
// ------------------------ END OF PARAVIEW OUTPUT BLOCK ------------------------

CudaDeviceFunction void RunBoundaries()
{	
	phaseField = phaseField(0,0);

	switch (NodeType & NODE_BOUNDARY) {
		case NODE_Wall:
			BounceBack();
			break;
		case NODE_DirichletEQ:  		
			// equilibrium scheme for BC - don`t care and impose rho*Teq
			// see chapter 5.3.4.2, eq 5.34, p191 from The Lattice Boltzmann Method: Principles and Practice
			// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen
			Init_eq(phaseField); 
			break; 
	}
}

CudaDeviceFunction void PhaseFieldSmoothing(){
	// this function is to smooth the boundaries after initialization.
	real_t lap_pf = phaseField(-1,0) + phaseField(1,0) + phaseField(0,-1) + phaseField(0,1) - 4*phaseField(0,0);
	real_t temp = phase_field_smoothing_coeff * phase_field_smoothing_coeff * lap_pf;
	phaseField = phaseField(0,0) + temp;
}

CudaDeviceFunction void Init() { 
	phaseField = Init_PhaseField;
	
	if ((NodeType & NODE_IMAGE) == NODE_ImageReader){
		// phaseField = (real_t)gray_scale_intensity*Init_PhaseField;
		phaseField = (real_t)gray_scale_intensity;
	}

	if(CylinderCenterX_GH > 0 && CylinderCenterY_GH > 0 && Sigma_GH > 0){ 
		// Gaussian Hill Benchmark
		real_t dx = X - CylinderCenterX_GH;
		real_t dy = Y - CylinderCenterY_GH;
		real_t L = dx*dx + dy*dy;
		phaseField *= exp(-L/(2*Sigma_GH));
	}
	
	//phaseField = getRandom();
	Init_eq(phaseField);
}

CudaDeviceFunction void Run() {
	if ((NodeType & NODE_ADDITIONALS) == NODE_Smoothing){
		PhaseFieldSmoothing();
		Init_eq(phaseField);
	}
	else{
		real_t omega_phi_soi=1.0/(3*diffusivity_phi+0.5);
		switch (NodeType & NODE_COLLISION) {
			case NODE_SRT_SOI_DF:
				relax_and_collide_SRT_DF_SOI(omega_phi_soi);
				break;    
			case NODE_SRT_SOI:
				relax_and_collide_SRT_SOI(omega_phi_soi);
				break;
			case NODE_TRT_SOI:
				relax_and_collide_TRT_SOI(omega_phi_soi);
				break;
		}

		AddToPhaseFieldIntegral(<?R C(sum(f)) ?>);   
	}
 }

 CudaDeviceFunction void BounceBack()
 {
	<?R 
		FullBounceBack()
   	?> 
 }

 CudaDeviceFunction void Init_eq(real_t Init_Phi) 
 {
	 //=== THIS IS AUTOMATICALLY GENERATED CODE ===
	 real_t Sigma2 = 0.3333333333333333;
	 //equilibrium in raw moment space
	 real_t f_eq_000 = Init_Phi;
	 real_t f_eq_100 = 0;
	 real_t f_eq_010 = 0;
	 real_t f_eq_200 = Init_Phi*Sigma2;
	 real_t f_eq_020 = Init_Phi*Sigma2;
	 real_t f_eq_110 = 0;
	 real_t f_eq_210 = 0;
	 real_t f_eq_120 = 0;
	 real_t f_eq_220 = Init_Phi*Sigma2*Sigma2;
	 //back to density-probability functions
	 f000 = f_eq_000 - f_eq_020 - f_eq_200 + f_eq_220;
	 f100 = 1/2.*f_eq_100 - 1/2.*f_eq_120 + 1/2.*f_eq_200 - 1/2.*f_eq_220;
	 f200 = -1/2.*f_eq_100 + 1/2.*f_eq_120 + 1/2.*f_eq_200 - 1/2.*f_eq_220;
	 f010 = 1/2.*f_eq_010 + 1/2.*f_eq_020 - 1/2.*f_eq_210 - 1/2.*f_eq_220;
	 f110 = 1/4.*f_eq_110 + 1/4.*f_eq_120 + 1/4.*f_eq_210 + 1/4.*f_eq_220;
	 f210 = -1/4.*f_eq_110 - 1/4.*f_eq_120 + 1/4.*f_eq_210 + 1/4.*f_eq_220;
	 f020 = -1/2.*f_eq_010 + 1/2.*f_eq_020 + 1/2.*f_eq_210 - 1/2.*f_eq_220;
	 f120 = -1/4.*f_eq_110 + 1/4.*f_eq_120 - 1/4.*f_eq_210 + 1/4.*f_eq_220;
	 f220 = 1/4.*f_eq_110 - 1/4.*f_eq_120 - 1/4.*f_eq_210 + 1/4.*f_eq_220;
 }


CudaDeviceFunction void relax_and_collide_SRT_DF_SOI(real_t omega_ade) 
{
	real_t tilde_phi = f000 + f010 + f020 + f100 + f110 + f120 + f200 + f210 + f220;

	real_t Q = getQ();

	real_t q000 = Q*4./9.;
	real_t q100 = Q*1./9.;
	real_t q200 = Q*1./9.;
	real_t q010 = Q*1./9.;
	real_t q110 = Q*1./36.;
	real_t q210 = Q*1./36.;
	real_t q020 = Q*1./9.;
	real_t q120 = Q*1./36.;
	real_t q220 = Q*1./36.;

	real_t feq000 = tilde_phi*4./9.;
	real_t feq100 = tilde_phi*1./9.;
	real_t feq200 = tilde_phi*1./9.;
	real_t feq010 = tilde_phi*1./9.;
	real_t feq110 = tilde_phi*1./36.;
	real_t feq210 = tilde_phi*1./36.;
	real_t feq020 = tilde_phi*1./9.;
	real_t feq120 = tilde_phi*1./36.;
	real_t feq220 = tilde_phi*1./36.;

	// alternatively_A
	feq000 += q000/2.;
	feq100 += q100/2.;
	feq200 += q200/2.;
	feq010 += q010/2.;
	feq110 += q110/2.;
	feq210 += q210/2.;
	feq020 += q020/2.;
	feq120 += q120/2.;
	feq220 += q220/2.;

	f000 = f000 + omega_ade*(feq000-f000);
	f100 = f100 + omega_ade*(feq100-f100);
	f010 = f010 + omega_ade*(feq010-f010);
	f200 = f200 + omega_ade*(feq200-f200);
	f020 = f020 + omega_ade*(feq020-f020);
	f110 = f110 + omega_ade*(feq110-f110);
	f210 = f210 + omega_ade*(feq210-f210);
	f120 = f120 + omega_ade*(feq120-f120);
	f220 = f220 + omega_ade*(feq220-f220);

	// alternatively_B
	// f000 += q000;
	// f100 += q100;
	// f010 += q010;
	// f200 += q200;
	// f020 += q020;
	// f110 += q110;
	// f210 += q210;
	// f120 += q120;
	// f220 += q220;

	// alternatively_A
	f000 += (1-omega_ade/2.)*q000;
	f100 += (1-omega_ade/2.)*q100;
	f010 += (1-omega_ade/2.)*q010;
	f200 += (1-omega_ade/2.)*q200;
	f020 += (1-omega_ade/2.)*q020;
	f110 += (1-omega_ade/2.)*q110;
	f210 += (1-omega_ade/2.)*q210;
	f120 += (1-omega_ade/2.)*q120;
	f220 += (1-omega_ade/2.)*q220;
}

CudaDeviceFunction void relax_and_collide_SRT_SOI(real_t omega_ade) 
{
		//=== THIS IS AUTOMATICALLY GENERATED CODE ===
		real_t Sigma2 = 0.3333333333333333;
		real_t tilde_phi = f000 + f010 + f020 + f100 + f110 + f120 + f200 + f210 + f220;
		 
		real_t Q = getQ();
		// Q = 0;  
	
		real_t temp000;
		real_t temp100;
		real_t temp010;
		real_t temp200;
		real_t temp020;
		real_t temp110;
		real_t temp210;
		real_t temp120;
		real_t temp220;
		 //--- processing f ---
		temp000 = f000;
		temp100 = f100;
		temp010 = f010;
		temp200 = f200;
		temp020 = f020;
		temp110 = f110;
		temp210 = f210;
		temp120 = f120;
		temp220 = f220;
		//raw moments from density-probability functions
		f000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
		f100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
		f010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
		f200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
		f020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
		f110 = temp110 - temp120 - temp210 + temp220;
		f210 = temp110 - temp120 + temp210 - temp220;
		f120 = temp110 + temp120 - temp210 - temp220;
		f220 = temp110 + temp120 + temp210 + temp220;
		//collide
		//collide-SOI
		real_t f_star_000 = Q - f000*omega_ade + f000 + omega_ade*tilde_phi;
		real_t f_star_100 = -f100*(omega_ade - 1.);
		real_t f_star_010 = -f010*(omega_ade - 1.);
		real_t f_star_200 = Q*Sigma2 + Sigma2*omega_ade*tilde_phi - f200*omega_ade + f200;
		real_t f_star_020 = Q*Sigma2 + Sigma2*omega_ade*tilde_phi - f020*omega_ade + f020;
		real_t f_star_110 = -f110*(omega_ade - 1.);
		real_t f_star_210 = -f210*(omega_ade - 1.);
		real_t f_star_120 = -f120*(omega_ade - 1.);
		real_t f_star_220 = Q*Sigma2*Sigma2 + Sigma2*Sigma2*omega_ade*tilde_phi - f220*omega_ade + f220;

		//back to density-probability functions
		f000 = f_star_000 - f_star_020 - f_star_200 + f_star_220;
		f100 = 1/2.*f_star_100 - 1/2.*f_star_120 + 1/2.*f_star_200 - 1/2.*f_star_220;
		f200 = -1/2.*f_star_100 + 1/2.*f_star_120 + 1/2.*f_star_200 - 1/2.*f_star_220;
		f010 = 1/2.*f_star_010 + 1/2.*f_star_020 - 1/2.*f_star_210 - 1/2.*f_star_220;
		f110 = 1/4.*f_star_110 + 1/4.*f_star_120 + 1/4.*f_star_210 + 1/4.*f_star_220;
		f210 = -1/4.*f_star_110 - 1/4.*f_star_120 + 1/4.*f_star_210 + 1/4.*f_star_220;
		f020 = -1/2.*f_star_010 + 1/2.*f_star_020 + 1/2.*f_star_210 - 1/2.*f_star_220;
		f120 = -1/4.*f_star_110 + 1/4.*f_star_120 - 1/4.*f_star_210 + 1/4.*f_star_220;
		f220 = 1/4.*f_star_110 - 1/4.*f_star_120 - 1/4.*f_star_210 + 1/4.*f_star_220;
}

 
CudaDeviceFunction void relax_and_collide_TRT_SOI(real_t omega_ade) 
{
	//=== THIS IS AUTOMATICALLY GENERATED CODE ===
	real_t Sigma2 = 0.3333333333333333;
	real_t tilde_phi = f000 + f010 + f020 + f100 + f110 + f120 + f200 + f210 + f220;
	// see eq. 7 from
	// "Optimal Stability of Advection-Diffusion Lattice Boltzmann Models 
	//  with Two Relaxation Times for Positive/Negative Equilibrium"
	// by I. Ginzburg, D. d’Humières, A. Kuzmin, 2010
	real_t omega_even = (-1.0 + 2.0/omega_ade)/(2.0*magic_parameter + 1.0);
	// real_t omega_even = 2. - omega_ade;  // to jakby gorsze
	
	real_t Q = getQ();

	real_t temp000;
	real_t temp100;
	real_t temp010;
	real_t temp200;
	real_t temp020;
	real_t temp110;
	real_t temp210;
	real_t temp120;
	real_t temp220;
	 //--- processing f ---
	temp000 = f000;
	temp100 = f100;
	temp010 = f010;
	temp200 = f200;
	temp020 = f020;
	temp110 = f110;
	temp210 = f210;
	temp120 = f120;
	temp220 = f220;
	//raw moments from density-probability functions
	f000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	f100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	f010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	f200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	f020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	f110 = temp110 - temp120 - temp210 + temp220;
	f210 = temp110 - temp120 + temp210 - temp220;
	f120 = temp110 + temp120 - temp210 - temp220;
	f220 = temp110 + temp120 + temp210 + temp220;
	//collide
	//collide-SOI
	// real_t f_star_000 = Q + tilde_phi;
	// real_t f_star_100 = -f100*(omega_ade - 1.);
	// real_t f_star_010 = -f010*(omega_ade - 1.);
	// real_t f_star_200 = Sigma2*(Q + tilde_phi);
	// real_t f_star_020 = Sigma2*(Q + tilde_phi);
	// real_t f_star_110 = 0;
	// real_t f_star_210 = -f210*(omega_ade - 1.);
	// real_t f_star_120 = -f120*(omega_ade - 1.);
	// real_t f_star_220 = Sigma2*Sigma2*(Q + tilde_phi);
	//collide-SOI - magic TRT
	real_t f_star_000 = Q - f000*omega_even + f000 + omega_even*tilde_phi;
	real_t f_star_100 = -f100*(omega_ade - 1.);
	real_t f_star_010 = -f010*(omega_ade - 1.);
	real_t f_star_200 = Q*Sigma2 + Sigma2*omega_even*tilde_phi - f200*omega_even + f200;
	real_t f_star_020 = Q*Sigma2 + Sigma2*omega_even*tilde_phi - f020*omega_even + f020;
	real_t f_star_110 = -f110*(omega_even - 1.);
	real_t f_star_210 = -f210*(omega_ade - 1.);
	real_t f_star_120 = -f120*(omega_ade - 1.);
	real_t f_star_220 = Q*Sigma2*Sigma2 + Sigma2*Sigma2*omega_even*tilde_phi - f220*omega_even + f220;

	//back to density-probability functions
	f000 = f_star_000 - f_star_020 - f_star_200 + f_star_220;
	f100 = 1/2.*f_star_100 - 1/2.*f_star_120 + 1/2.*f_star_200 - 1/2.*f_star_220;
	f200 = -1/2.*f_star_100 + 1/2.*f_star_120 + 1/2.*f_star_200 - 1/2.*f_star_220;
	f010 = 1/2.*f_star_010 + 1/2.*f_star_020 - 1/2.*f_star_210 - 1/2.*f_star_220;
	f110 = 1/4.*f_star_110 + 1/4.*f_star_120 + 1/4.*f_star_210 + 1/4.*f_star_220;
	f210 = -1/4.*f_star_110 - 1/4.*f_star_120 + 1/4.*f_star_210 + 1/4.*f_star_220;
	f020 = -1/2.*f_star_010 + 1/2.*f_star_020 + 1/2.*f_star_210 - 1/2.*f_star_220;
	f120 = -1/4.*f_star_110 + 1/4.*f_star_120 - 1/4.*f_star_210 + 1/4.*f_star_220;
	f220 = 1/4.*f_star_110 - 1/4.*f_star_120 - 1/4.*f_star_210 + 1/4.*f_star_220;
}

