
// 'Lattice Boltzmann model for simulating flows with multiple phases and components' by X. Shan and H. Chen, 1993
// 'Simulation of nonideal gases and liquid-gas phase transitions by the lattice Boltzmann equation' by X. Shan and H. Chen, 1994

// This type of models are also know as pseuodo-potential models.

<?R 
	source("conf.R")
	c_header();
	source("lib/feq.R")
    source("lib/boundary.R")

    if (Options$d3q19){
        ## D3Q19
        D=3
        Q=19
    } else {
        # D2Q9
        D=2
        Q=9
    }
    xyz = c('x','y','z')
    xyz = xyz[1:D]
    XYZ = c('X','Y','Z')
    XYZ = XYZ[1:D]

    
?>
CudaDeviceFunction float2 Color() {
  float2 ret;
  ret.x = getRho();
  ret.y = 1;
  return ret;
}

CudaDeviceFunction real_t getRho() {
    return rho(0,0);
}


CudaDeviceFunction vector_t getU() {
    vector_t u;
    u.z = 0;
    <?R 
        C(PV(paste("u.",xyz,sep="")), PV(paste("J",xyz,"(0,0)/rho(0,0)",sep="")))
    ?>
    return u;
}

CudaDeviceFunction void Init() {
    <?R 
        C(PV(paste("J",xyz,sep="")), PV(paste("Velocity",XYZ,"*Density",sep="")))
    ?>
    rho = Density;
 }


CudaDeviceFunction real_t getPsi(const real_t rho2){
    #define a2 3.852462271644162
    #define b2 0.1304438860971524 * 4.0 
    #define c2 2.785855170470555
    #define t Temperature
    #define Magic Kupershtokh_K
    real_t p;
    
	p =((rho2*(-pow(b2,3)*pow(rho2,3)/64.+b2*b2*rho2*rho2/16.+b2*rho2/4.+1)*t*c2)/pow(1-b2*rho2/4.,3)-a2*rho2*rho2);
	p = Magic*p;
	return sqrt( -p + rho2/(3.) );

}
CudaDeviceFunction void Run() { 


vector_t F[<?%s Q ?>];
real_t R[<?%s Q ?>];


<?%s paste("real_t J",xyz,"_i[",Q,"];",sep="") ?>
real_t rho_i[<?%s Q ?>];



real_t Phi<?%s paste(list("[5]")[rep(1,D)],collapse="") ?>;

<?R
    x = c(0,1,-1);
    xx = list(x)[rep(1,D)]
    U = as.matrix(do.call(expand.grid, xx))

    lengths = apply(U^2,1,sum)
    if( D == 3) {
        if (Q == 19){
            qsel = lengths < 3
        } else if (Q == 27) {
            qsel = lengths < 4
        }
        U = U[qsel,]
    }

    Gravitation = PV(c("GravitationX","GravitationY","GravitationZ"))


    feq = PV(paste("tmp[",1:Q-1,"]",sep=""))

    kk = as.matrix(do.call(expand.grid, list(seq(-2,2))[rep(1,D)] ))



    collapse <- function(what, sep,dim){
        return(apply( what, 1, paste , collapse = sep))
    }

    C(PV(paste("Phi[",collapse(kk+2, ']['),"]",sep="")) , PV(paste("phi(",collapse(kk, ','),")")));

    # for (k in seq(-2,2))
    # {
    #     for (q in seq(-2,2))
    #     {
    #        C(PV(paste("Phi[",k+2,"][",q+2,"]",sep="")) , PV(paste("phi(",k,",",q,")")));
    #     }
    # }   
    for (i in seq(1,Q))
    {
        

        #C(R , PV(paste("getPsi(rho(",apply( -U-U[i,] , 1, paste , collapse = "," ),"))")));

        R = PV(c(paste("R[",1:Q-1,"]",sep="")))
#        Rt = PV(c(paste("//R[",1:9-1,"]",sep="")))
#        C(Rt , PV(paste("getPsi(rho(",-U[i,1]-U[,1],",",-U[i,2]-U[,2],"))")));
        C(R , PV(paste("Phi[", collapse( t(-t(U)-U[i,])+2 , "][" ) ,"]",sep="")) );

        Force = PV(c(paste("F[",i-1,"].x",sep=""),paste("F[",i-1,"].y",sep=""),paste("F[",i-1,"].z",sep="")));
        
        #gs = c(0,1,1,1,1,1/4,1/4,1/4,1/4);

        gs = U[,1]
        sel = apply(U^2,1,sum)
        
        gs[] = 1
        if (Q == 9){
            gs[sel > 1] = 1/4
            alpha = -2/3.
        } else if (Q == 19){
            gs[sel > 1] = 1/2
            alpha = -1/3.
        }
        
        gs[sel == 0] = 0
            
        
        A = PV("Kupershtokh_A")
        C(R[-1] , (R * R * A + R * R[1] * (A*(-2)+1))[-1],float=F)
        C(Force[1:D] , alpha*(R*gs) %*% U)



        #rho_i = PV(paste("rho(",-U[i,1],",",-U[i,2],")"))
        JinR = PV(c( paste("Jx(",paste(-U[i,],collapse=' , '),")"),
                     paste("Jy(",paste(-U[i,],collapse=' , '),")"),
                     paste("Jz(",paste(-U[i,],collapse=' , '),")")))

        JinR = JinR + Force + Gravitation
        #xyz = c('x','y','z')
        
        J_i = PV(paste("J",xyz,"_i[ ",i-1," ]", sep=""))
        #J_i = JinC[1:D]

        C(J_i, JinR[1:D] )
        
        rho_i = PV(paste("rho_i[",i-1,"]"))
        C(rho_i, PV(paste("rho(",paste(-U[i,],collapse=' , '),")")))

        
        EQi = MRT_eq(U, rho_i, J_i, order=3, ortogonal=FALSE);

        feq[i] = EQi$feq[i]
    }

    mpost = feq%*%EQi$mat

    J = PV(c('Jx','Jy','Jz'))

    C(PV('rho'), mpost[1])
    C(J[1:D], mpost[2:(D+1)])
    C(PV('phi'), PV("getPsi(rho)"))




?>


  if (IamWall)  {
    <?R
        C(J[1:D], 0)
    ?>
    rho = 1;
  }
}