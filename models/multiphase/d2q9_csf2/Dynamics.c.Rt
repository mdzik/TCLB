<?R
# #############
# based on "Conservative phase-field lattice Boltzmann model for interface tracking equation"
# implemented by M. Dzikowski 2016
# #############

	source("conf.R") 
	c_header();
	
	source("lib/feq.R")
	source("lib/boundary.R")

    U = t(as.matrix(   rbind( Density$dx[Density$group=='f'], Density$dy[Density$group=='f'] ) ))


	f = PV(Density$name[Density$group=='f'])
	rho = PV("rho")
	J = PV("J",c("x","y"))
    u = PV(c("u.x","u.y"))


    BC_Velocity=PV(c('VelocityX', 'VelocityY'))
# things related to h
    h  = PV(Density$name[Density$group=='h'])
    pf = PV("pf")
    n = PV(c("n.x","n.y"))
    W = PV("IntWidth")	
    n = c(PV('n.x'),PV('n.y'))
     
    Mobility = PV("Mobility")
 
    UN = t(U[1:9,])
    phis = PV(paste('phi(',UN[1,],',',UN[2,],')'))   
    


##########################################################################
# Calculating equlibrium density set

	EQ_NO = MRT_eq(U, rho, J, ortogonal=FALSE, order=12);
	
	get.M.matrix = function(a) {
	  an = lapply(a@vec,names)
	  an = unique(do.call(c,an))
	  an = setdiff(an,".M")
	  ret = lapply(a@vec,function(p) { nan = setdiff(an,names(p)); p[,nan] = 0; p})
	  n = length(ret)
	  for (i in seq_len(n)) names(ret[[i]])[names(ret[[i]]) == ".M"] = paste0(".M",i)
	  m=ret[[1]]
	  for (i in seq_len(n-1)+1) m = merge(x=m,y=ret[[i]],all=TRUE,suffixes = c("a","b"))
	  m[is.na(m)] = 0
	  as.matrix(m[,paste0(".M",1:n)])
	}
	


	M = EQ_NO$mat
    if (Options$TRT) {
    } else if (Options$BGK) {
        M = diag(nrow(M))
    } else if (Options$WMRT) {
        A = get.M.matrix(EQ_NO$Req)
        R = diag(nrow = ncol(A))
        R[1:nrow(A),] = qr.R(qr(A))
        R = R / diag(R)
        M = EQ_NO$mat %*% solve(R)
    } else {
    }

	
	if (Options$HiOrd) {
		EQ = MRT_eq(U, rho, J, ortogonal=FALSE, order=12,mat=M);
		EQ_H = MRT_eq(U, pf, u*pf, ortogonal=FALSE, order=12,mat=M);
	} else {
		EQ = MRT_eq(U, rho, J, ortogonal=FALSE, mat=M);
		EQ_H = MRT_eq(U, pf, u*pf, ortogonal=FALSE, mat=M);
	}

    pvzero = PV('a') - PV('a')
    pvone = 1 + pvzero 
    #CounterDiffusiveSourceTerm
    wi = MRT_eq(U, pvone, c(pvzero, pvzero), ortogonal=FALSE,mat=M)$feq;
    

#############################################
### END CONFIG
#############################################

?>
//################################################################################################
//Helper functions 
//################################################################################################

CudaDeviceFunction real_t evalOmega(const real_t _pf){
    <?R if (!Options$ViscositySmooth) { ?>
        real_t omega = _pf > 0 ? omega_plus : omega_minus;
    <?R } else { ?>

     const real_t mu_minus = nu_minus * (-0.5);
        const real_t mu_plus = nu_plus * 0.5;
        const real_t mu =  ( mu_l +  (_pf - 0.5) * (mu_minus - mu_plus) / (-0.5 - 0.5  + 1E-16) );
        real_t omega = 1.0/( 3. * mu / 1. + 0.5);
    <?R } ?>
    return omega;
}


CudaDeviceFunction vector_t getF() {
    vector_t Force = real_getInterfaceForce(SurfaceTensionRate);
    return Force;
}

CudaDeviceFunction vector_t getInterfaceForce(){
    InitPhisStencil();
    return real_getInterfaceForce(1);
}


CudaDeviceFunction vector_t real_getInterfaceForce(const real_t ST) {
	vector_t F = gradient;
    real_t curv = curvature;
    real_t phi_l = phi ;
    if (phi_l * phi_l < SurfaceTensionDecay){
    F.x =  ST * curv   *  F.x; 
    F.y =  ST * curv   *  F.y;

/**    
#TODO
    if (near_wall){
        F.x = F.x * WallAdhesionDecay;
        F.y = F.y * WallAdhesionDecay;
    }

    F.z = 0;
    const real_t s = sin(0.5*pi - WettingAngle);
    F.x =  ST * (curv + 2*h_Z*s)  *  F.x; // exp(- SurfaceTensionDecay * phi_l*phi_l);
    F.y =  ST * (curv + 2*h_Z*s)  *  F.y;// exp(- SurfaceTensionDecay * phi_l*phi_l);
**/


    } else {
        F.x = 0;
        F.y = 0;
        F.z = 0;
    }
	return F;
}


vector_t normal;
real_t curvature;
vector_t gradient;
vector_t debug;
bool near_wall;

#define buffSize 4

#define pi 3.141592653589793116
#define w0 0x0
#define w1 0x01 // hex for 0000 0001
#define w2 0x02 // hex for 0000 0010
#define w3 0x04 // hex for 0000 0100
#define w4 0x08 // hex for 0000 1000
#define w5 0x10 // hex for 0001 0000
#define w6 0x20 // hex for 0010 0000
#define w7 0x40 // hex for 0100 0000
#define w8 0x80 // hex for 1000 0000
 
#define s0 0
#define s1 0
#define s2 1
#define s3 2
#define s4 3
#define s5 4
#define s6 5
#define s7 6
#define s8 7

CudaDeviceFunction void CalcPhi() {
    if ( (NodeType & NODE_BOUNDARY) == NODE_NSymmetry ){
       real_t ret = 0;
       <?R 
        ret = PV("ret")
        for (j in (1:9)[ U[,2] > 0 ]) {
            op_i = (1:9)[U[,2]+U[j,2] == 0 & U[,1]-U[j,1] == 0] 
            C( ret , ret + h[op_i])                 
        }
        sel = (1:9)[U[,2]<=0]
        C(ret , ret + h[sel])            
       ?>
       phi =  ret;

   }

   if ( (NodeType & NODE_BOUNDARY) == NODE_SSymmetry ){
        real_t ret = 0;
        <?R 
        ret = PV("ret")

        for (j in (1:9)[ U[,2] < 0 ]) {
            op_i = (1:9)[U[,2]+U[j,2] == 0 & U[,1]-U[j,1] == 0] 
            C( ret , ret + h[op_i])                
        }
        sel = (1:9)[U[,2]>=0]
        C(ret , ret + h[sel])     
        ?>
        phi =  ret;

   }


   if ((NodeType & NODE_BOUNDARY) == NODE_Wall) {
        phi =  -999;
   } else {
    	phi =  <?R C(sum(h)) ?> ;
   }  
    
    
}
CudaDeviceFunction void  InitPhisStencil(){

    gradient.x = 0;
    gradient.y = 0;
    curvature = 0;

    debug.x = 0;
    debug.y = 0;
    debug.z = 0;

    CalcPhi();

    return;
    
    if(IamWall){
	    gradient.x = 0;
    	gradient.y = 0;
	    curvature = 0;
    } else {

    debug.x = 0;
    debug.y = 0;
    debug.z = 0;

    CalcPhi();
    
    vector_t n, nw;
    n.x = 0;
    n.y = 0;
    nw.x = 0;
    nw.y = 0;
    int inwall = 0;

    real_t ctg_alpha = 0;
    unsigned int wall_pattern = 0x0;

    switch (NodeType & NODE_BOUNDARY) {
    case NODE_SSymmetry:
            <?R j = 2 ?>     
            n.x = n.x + <?R C(phis[j]*wi[j]*U[j,1]) ?>;

            <?R j = 4 ?>     
            n.x = n.x + <?R C(phis[j]*wi[j]*U[j,1]) ?>;
                 
            <?R j = 6 ?>
            n.x = n.x + <?R C(2*phis[j]*wi[j]*U[j,1]) ?>;

            <?R j = 7 ?>
            n.x = n.x + <?R C(2*phis[j]*wi[j]*U[j,1]) ?>;

            <?R j = 3 ?>
            n.x = n.x + <?R C(2*phis[j]*wi[j]*U[j,1]) ?>;

        break;
    case NODE_NSymmetry:
            <?R j = 2 ?>     
            n.x = n.x + <?R C(phis[j]*wi[j]*U[j,1]) ?>;

            <?R j = 4 ?>     
            n.x = n.x + <?R C(phis[j]*wi[j]*U[j,1]) ?>;
                 
            <?R j = 9 ?>
            n.x = n.x + <?R C(2*phis[j]*wi[j]*U[j,1]) ?>;

            <?R j = 8 ?>
            n.x = n.x + <?R C(2*phis[j]*wi[j]*U[j,1]) ?>;

            <?R j = 5 ?>
            n.x = n.x + <?R C(2*phis[j]*wi[j]*U[j,1]) ?>;
        break;
    default:
       <?R
        for (j in 1:9) {
        ?> 
            if (<?R C(phis[j]) ?>  != -999) {
                n.x = n.x + <?R C(phis[j]*U[j,1]*wi[j]) ?>;
                n.y = n.y + <?R C( phis[j]*U[j,2]*wi[j]) ?>;
            } else {
                wall_pattern = wall_pattern + w<?%s j-1 ?>;
            }
        <?R } ?>
        break;
    }

    real_t ln = sqrt(n.x*n.x + n.y*n.y);    
    if(ln == 0.){
        n.x = 0.;
        n.y = 0.;
    } else {
        n.x /= ln;
        n.y /= ln;
    }

    near_wall = !(wall_pattern == 0);

    real_t t1,t2;
    real_t my = 0;
    real_t mx = 0;
    real_t mxy = 0;
    
    if (near_wall && (wall_pattern != 255)){

        nw.x = nw_x(0,0);
        nw.y = nw_y(0,0);
        nw_x = nw_x(0,0);
        nw_y = nw_y(0,0);
        
        real_t ln = sqrt(nw.x*nw.x + nw.y*nw.y);    
        if(ln == 0.){
            nw.x = 0.;
            nw.y = 0.;
        } else {
            nw.x /= -ln;
            nw.y /= -ln;
        }

        vector_t temp, temp1;
        real_t ca = cos(WettingAngle);
        real_t sa = sin(WettingAngle);
        temp.x = ca * nw.x + sa * nw.y - n.x;
        temp.y = -sa * nw.x + ca * nw.y - n.y;
        real_t l1 = sqrt(temp.x * temp.x + temp.y * temp.y);

        
        sa = -sa; //oposite rotation
        temp1.x = ca * nw.x + sa * nw.y - n.x;
        temp1.y = -sa * nw.x + ca * nw.y - n.y;
        real_t l2 = sqrt(temp1.x * temp1.x + temp1.y * temp1.y);
    
        real_t wa = 0;
        if ( l2 < l1 ) {
            wa = -WettingAngle;
        } else {
            wa = WettingAngle;
        }
          
        ctg_alpha = tan(wa+pi/2.);
        unsigned btype = 0x0;

 
    }

    const int aj = buffSize;
    int ajj = 0;
    const int ai = buffSize;
    real_t A[buffSize][buffSize];
    real_t B[buffSize][buffSize];
    real_t y[buffSize];
    int iwrite = 0;  
    real_t wx,wy,wc;
    real_t temp[buffSize];
    gradient.x = 0;
    gradient.y = 0;
    gradient.z = 0;
    curvature = 0;
    wx = 0;
    wy = 0;
    wc = 0;


	const real_t A0_BC[4] = {
            0,
            ctg_alpha*nw.y - nw.x,
            -ctg_alpha*nw.x - nw.y,
            0  
	};
    bool pid_cond;

	const real_t A0[16] = {
		 1, 1, 1, 1,
		-1, 1, 1,-1,
		-1,-1, 1, 1,
		 1,-1, 1,-1
	};

 <?R 
    boxes = array(c(
        c(0,1,5,2),
        c(3,0,2,6),
        c(7,4,0,3),
        c(4,8,1,0)
    ), dim=c(4,4))   

    boxes_SS = array(c(
                  c(0,1,5,2),
                  c(3,0,2,6),
                  c(6,2,0,3),
                  c(2,5,1,0)
               ), dim=c(4,4))    

    boxes_NS =  array(c(
                  c(0,1,8,4),
                  c(3,0,4,7),
                  c(7,4,0,3),
                  c(4,8,1,0)
               ), dim=c(4,4))   
    
    signs = array(c(
        c(1,1),
        c(1,-1),
        c(-1,-1),
        c(-1,1)
    ), dim=c(2,4))


    A0 = array(c(
                c(1,1,1,1),
                c(-1,1,1,-1),
                c(-1,-1,1,1),
                c(1,-1,1,-1)
        ),dim=c(4,4))

    for (box_i in c(1:4)){
        ?>
        ajj = 0;
        for(int i = 0; i < buffSize; i++){
           for(int j = 0; j < buffSize; j++){
              A[i][j] = 0;  
              B[i][j] = 0;
           }
           y[i] = 0;
           temp[i] = 0;
        }



        switch (NodeType & NODE_BOUNDARY) {
            case NODE_SSymmetry:
            <?R
            box = boxes_SS[,box_i]
            box_phis = phis[box+1]     
            ?>
            <?R for (pid in c(1:4)){ ?>
                pid_cond =  (wall_pattern >> s<?%s box[pid]?> & 0x1 ) ; 
                <?R for (fid in c(1:4)){  ?>
                    A[<?%s fid-1 ?>][<?%s pid-1 ?>] = pid_cond ? A0_BC[<?%s fid-1 ?>] : <?%s A0[pid,fid] ?>;
                <?R } ?>
                y[<?%s pid-1 ?>] = pid_cond ? 0 : <?R C(box_phis[pid]) ?> ;
                ajj += pid_cond ? 0 : 1;

            <?R } ?>
                break;
            case NODE_NSymmetry:
            <?R
            box = boxes_NS[,box_i]
            box_phis = phis[box+1]     
            ?>
            <?R for (pid in c(1:4)){ ?>
                pid_cond =  (wall_pattern >> s<?%s box[pid]?> & 0x1 ) ; 
                <?R for (fid in c(1:4)){  ?>
                    A[<?%s fid-1 ?>][<?%s pid-1 ?>] = pid_cond ? A0_BC[<?%s fid-1 ?>] : <?%s A0[pid,fid] ?>;
                <?R } ?>
                y[<?%s pid-1 ?>] = pid_cond ? 0 : <?R C(box_phis[pid]) ?> ;
                ajj += pid_cond ? 0 : 1;

            <?R } ?>

                break;
                
            default:
            <?R
            box = boxes[,box_i]
            box_phis = phis[box+1]     
            ?>
            <?R for (pid in c(1:4)){ ?>
                pid_cond =  (wall_pattern >> s<?%s box[pid]?> & 0x1 ) ; 
                <?R for (fid in c(1:4)){  ?>
                    A[<?%s fid-1 ?>][<?%s pid-1 ?>] = pid_cond ? A0_BC[<?%s fid-1 ?>] : <?%s A0[pid,fid] ?>;
                <?R } ?>
                y[<?%s pid-1 ?>] = pid_cond ? 0 : <?R C(box_phis[pid]) ?> ;
                ajj += pid_cond ? 0 : 1;

            <?R } ?>
        }
        // orthogonalize
        
        iwrite = 0;
        for (int iread=0; iread<buffSize; iread++){
            
            for(int j = 0; j < aj; j++){
                temp[j] = A[iread][j];   
            }
            
            for (int i=0; i<iread; i++){
                t1 = 0;
                for(int j = 0; j < aj; j++){
                    t1 = t1 + A[i][j]*temp[j];   
                }          
                
                for(int j = 0; j < aj; j++){
                    temp[j] = temp[j] - t1*A[i][j];   
                }                                     
                B[iwrite][i] = t1;
            }
           
            t1 = 0;
            for(int i = 0; i < ai; i++){
                t1 = t1 + temp[i]*temp[i];
            }     
            

            if (t1*t1 > 1E-16){
                t1 = sqrt(t1);
            
                for(int i = 0; i < ai; i++){
                    temp[i] /= t1;
                }         

                t1 = 0;
                
                for(int j = 0; j < aj; j++){
                    t1 = t1 + A[iread][j]*temp[j];   
                }          
                
                B[iwrite][iwrite] = t1;
                
                for(int j = 0; j < aj; j++){
                    A[iwrite][j] = temp[j];   
                }

            } else {
                for(int j = 0; j < buffSize; j++){
                    A[iwrite][j] = 0;   
                }
                B[iwrite][iwrite] = 1;
           
            } 

            iwrite++;
        }

        


        //////////////////////////////
        // Solve the system

        for (int i=0; i < buffSize; i++){
            temp[i] = 0;
            for (int j = 0; j< buffSize; j++){
                temp[i] = temp[i] + y[j] * A[i][j];
            }        
        }

        for (int i=ai-1; i >= 0; i--){
            y[i] = temp[i]; 
            for (int j = i+1; j < aj ; ++j){
                y[i] = y[i] - y[j] * B[j][i];
            }        
            y[i] = y[i] / B[i][i];
        }


        mx = y[1] / 2.;
        my = y[2] / 2.;
        t1 = sqrt(mx*mx + my*my) + 1E-18;
        curvature +=  ( ( <?%s signs[2,box_i]  ?> )*mx + ( <?%s signs[1,box_i]  ?> )*my ) / t1;

        gradient.y = gradient.y + y[2] / 2.;
        gradient.x = gradient.x + y[1] / 2.;

<?R }  ?>


gradient.z = 0;

curvature = -0.5 * curvature;

normal.x = nw.x;
normal.y = nw.y;
normal.z = 0;

debug.x = gradient.x;
debug.y = gradient.y;
    } //end IaAmWall-Else
////END
}






//################################################################################################
// Export-only functions
//################################################################################################

#define pi 3.141592653589793116

CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?> ;
}

//only for paraview: do not use, inefficient!!
CudaDeviceFunction real_t getPhaseField(){
        InitPhisStencil();
        if (IamWall){
            return 0;
        }
    	return phi ;
}
    
CudaDeviceFunction vector_t getNormal(){
    InitPhisStencil();
    vector_t n = gradient;

    real_t l = sqrt( n.x * n.x + n.y * n.y);
    
    if (l != 0){
      n.x = n.x / l ;
      n.y = n.y / l ;
    } else {
      n.x = 0;
      n.y = 0;
    }

    return n;

}



//only for paraview: do not use, inefficient!!
CudaDeviceFunction real_t getCurvature(){
    InitPhisStencil();
    return curvature;

}
//only for paraview: do not use, inefficient!!
CudaDeviceFunction vector_t getDEBUG(){
    InitPhisStencil();
    return debug;
}




CudaDeviceFunction vector_t getU(){
	real_t d = <?R C(sum(f)) ?>;
	vector_t u,F;
    F = getF();
<?R C( PV(c("u.x","u.y")), f %*% U ) ?>
<?R C( PV(c("const real_t pf")), sum(h) ) ?>
	u.x /= d;
	u.y /= d;
	u.z = 0.0;

    real_t GravitationX = pf > 0 ? GravitationX_plus : GravitationX_minus;
    real_t GravitationY = pf > 0 ? GravitationY_plus : GravitationY_minus;

    u.x += (GravitationX + F.x/d) * 0.5;
    u.y += (GravitationY + F.y/d) * 0.5;

	return u;
}

CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}


//################################################################################################
// Init functions
//################################################################################################



CudaDeviceFunction void Init() {
	real_t rho, Jx, Jy, C;
	rho = (1+Pressure*3);
	Jy = rho*VelocityY;
	Jx = rho*VelocityX;
    C = PhaseField; 


<?R
#	feq = EQ$Req %*% solve(EQ$mat)
	C( f, EQ$feq)
    C( h,  PV('PhaseField') * wi  )

?>
    vector_t u,n;
    n.x = 0;
    n.y = 0;
}

//################################################################################################
// Wall normall handling functions
//################################################################################################


//only for paraview: do not use, inefficient!!
CudaDeviceFunction vector_t getWallNormal(){
    vector_t nw;
    nw.x = 0;
    nw.y = 0;
    nw.z = 0;
    if (!IamWall) {
        nw.x = nw_x(0,0);
        nw.y = nw_y(0,0);
        real_t ln = sqrt(nw.x*nw.x + nw.y*nw.y);    
        if(ln == 0.){
            nw.x = 0.;
            nw.y = 0.;
        } else {
            nw.x /= -ln;
            nw.y /= -ln;
        }
    }
    return nw;

}


CudaDeviceFunction void CalcNormal(){


    CalcPhi();


    //calculate gradient and normal
    vector_t nw;
    nw.x = 0;
    nw.y = 0;
    nw.z = 0;

    real_t magic = 0.12; //TODO WallSmoothingMagic;
    bool has_normal = false;
    <?R
    for (j in 1:9) {
    ?>
        if (<?R C(phis[j]) ?>  == -999) {
            nw.x = nw.x + (1-magic) * <?R C(U[j,1]) ?>;
            nw.y = nw.y + (1-magic) * <?R C(U[j,2]) ?>;
            has_normal = true;
        }

        nw.x = nw.x + magic * nw_x(  <?R C(U[j,1]) ?>,   <?R C(U[j,2]) ?> );
        nw.y = nw.y + magic * nw_y(  <?R C(U[j,1]) ?>,   <?R C(U[j,2]) ?> );
    <?R } ?>

    real_t ln = sqrt(nw.x*nw.x + nw.y*nw.y) + 1E-8;
    nw.x /= ln;
    nw.y /= ln;

    if (IamWall || !has_normal){
        nw.x = 0;
        nw.y = 0;
    }
    nw_x = nw.x;
    nw_y = nw.y;
    


}

//################################################################################################
// BC handling functions
//################################################################################################

<?R 
# define standard ZueHe BC's
bc_node_names = c("EVelocity" , "WVelocity","SVelocity", "EPressure", "WPressure", "NPressure", "SPressure")
bc_node_directions = rbind(c(1,0), c(-1,0),c(0,-1), c(1,0), c(-1,0), c(0,1), c(0,-1))
bc_node_utype = c("velocity","velocity", "velocity", "pressure", "pressure", "pressure", "pressure")

?>


CudaDeviceFunction void Run() {
    
    InitPhisStencil();

    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Solid:
	case NODE_Wall:
		BounceBack();
		break;
/// START AUTOGENERATED BC
<?R
for (i in seq(1,length(bc_node_names))){
?>
	case NODE_<?%s bc_node_names[i] ?>:
		<?%s bc_node_names[i] ?>();
		break;
<?R
    }
?>
    }
/// END AUTOGENERATED BC
    if (NodeType & NODE_MRT)
    {
		CollisionMRT();
    }
}

CudaDeviceFunction void BounceBack()
{
<?R FullBounceBack() ?>
}

<?R

for (i in seq(1,length(bc_node_names))){
    ?>
        CudaDeviceFunction void <?%s bc_node_names[i] ?>()
        {
            {
        <?R 
            if (bc_node_utype[i] == 'velocity'){
                ZouHeRewrite(EQ,   f, bc_node_directions[i,], type=bc_node_utype[i], BC_Velocity)
            } else {
                ZouHeRewrite(EQ,   f, bc_node_directions[i,], type=bc_node_utype[i])
            }
        ?>
            }
            {
        <?R
            ZouHeRewrite(EQ_H, h, bc_node_directions[i,], type="pressure", rhs=PV('PhaseField'))
        ?>
            }
        }
    <?R
}
?>


//################################################################################################
// Collision handling functions
//################################################################################################


CudaDeviceFunction void CollisionMRT()
{	
<?R
	
  Omega = PV(rep("omega",nrow(U)))
  if (Options$TRT) {
	Omega[EQ$order %% 2 == 1] = PV("omega2")
  } else if (Options$BGK) {
  
  } else if (Options$WMRT) {

  } else {
  	Omega[EQ$order > 2] = PV(1)
  }

  if (any(EQ$order < 2)) Omega[EQ$order < 2] = PV(1)
  

  meq = EQ$Req
  
  if (Options$FMT) {
	I = do.call(expand.grid,list(0:2,0:2))
	M = do.call(PV,c("f",unclass(I)))
	sel = ToC(M) %in% ToC(f)
	FMT(I, M, sel)
	m = M[sel]
	m = m[EQ_NO$canonical]
	C(m, m %*% solve(EQ_NO$mat) %*% EQ$mat)
  } else {
  	m = PV("m",1:ncol(EQ$mat)-1)
  	cat("real_t",paste(ToC(m),collapse=","),";\n")
  	C(m, f %*% EQ$mat)
  }

?>
	real_t rho, Jx, Jy, pf;
<?R
  C(PV(c("rho","Jx","Jy")), m %*% solve(EQ$mat) %*% cbind(1,U))
  C(PV(c("pf")), sum(h))
?>

    vector_t F = getF();
    real_t GravitationX = pf > 0 ? GravitationX_plus : GravitationX_minus;
    real_t GravitationY = pf > 0 ? GravitationY_plus : GravitationY_minus;

    vector_t u; //velocity for advection
    u.x = Jx /rho;
    u.y = Jy /rho;

    u.x += (GravitationX + F.x/rho) * 0.5;
    u.y += (GravitationY + F.y/rho) * 0.5;

    u.z = 0;
	real_t omega = evalOmega(pf);
	real_t omega2 = (2.0 - omega)/(1 + 2*(Magic-0.25)*omega);
<?R

  C(m, m - meq)
  C(m, m*(1-Omega))


?>  


  Jx = Jx + F.x + (GravitationX*rho);
  Jy = Jy + F.y + (GravitationY*rho); 
// This is equall to  EDM (but faster): C(m, (m - meq)*(1-Omega) + meg + meq_du - meq )
<?R 
  C(m, m + meq)

  if (Options$FMT) {
	C(m, m %*% solve(EQ$mat) %*% EQ_NO$mat)
	FMT(I, M, sel, inverse = TRUE)
  } else {
  	C(f, m %*% solve(EQ$mat))
  }
?>
//////////////////////////////////////////////////////
// COLLIDE H
//////////////////////////////////////////////////////
    real_t omega_ph =  1./( 3 * Mobility + 0.5); 
    real_t omega_ph2 = (2.0 - omega_ph)/(1 + 2*(Magic-0.25)*omega_ph);

    vector_t n = gradient;

    real_t l = sqrt( n.x * n.x + n.y * n.y);

    if (l != 0){
        n.x = n.x / l ;
        n.y = n.y / l ;
    } else {
        n.x = 0;
        n.y = 0;
    }


<?R
    
    Omega = PV(rep("omega_ph",nrow(U)))
    if (Options$TRT) {
        Omega[EQ_H$order %% 2 == 0] = 1
    } else if (Options$BGK) {

    } else if (Options$WMRT) {

    } else {
        Omega[EQ_H$order > 2] = PV(1)
    }

    if (any(EQ_H$order < 1)) Omega[EQ_H$order < 2] = PV(1)
    Omega[EQ_H$order == 1] = PV("omega_ph")


    CDST0 = 3*Mobility * (1.-4.*pf*pf)* W  * wi * n %*% t(U)

    
    meq = EQ_H$Req

    #C(tmp,CDST %*% EQ_H$mat) gives:
    #tmp[1] = ( 1 - pf*pf*4. )*n.x*IntWidth*Mobility;
    #tmp[2] = ( 1 - pf*pf*4. )*n.y*IntWidth*Mobility;
    #tmp[i] = 0

    C(m, h %*% EQ_H$mat)
    C(m, m - meq)
    C(m, m*(1-Omega))

    Omega[EQ_H$order < 1] = PV(1)
    Omega[EQ_H$order > 1] = PV(1)
    Omega[EQ_H$order == 1] = PV("omega_ph")

    C(m, m + Omega*(CDST0 %*% EQ_H$mat))

    C(m, m + meq)
    C(h, m %*% solve(EQ_H$mat))

?>
}
